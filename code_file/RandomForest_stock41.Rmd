---
title: "RandomForest"
author: '510055611'
date: "2023-04-02"
output: html_document
---

```{r}
#stock 21 and stock 7
```


```{r,message=FALSE}
library(randomForest)
library(readr)
library(dplyr)
library(ggplot2)
```

```{r}
read_csv_file <- function(file) {
  read_csv(file, col_types = cols())
}
```


```{r,message=FALSE}
stock_names = "stock_41.csv"
```

```{r}

path <- "/Users/cco/Desktop/individual_book_train/"
files <- paste0(path, stock_names)

```


```{r,message=FALSE}
data_frames <- lapply(files, function(file) {
  cat("Reading file:", file, "\n")
  read_csv(file)
})
```


```{r}
for (i in 1:length(data_frames)) {
  
  stocki = data_frames[[i]]
  
  WAP = (stocki$bid_price1*stocki$ask_size1 + stocki$ask_price1 * stocki$bid_size1)/(stocki$bid_size1 + stocki$ask_size1)
  data_frames[[i]] = stocki %>%
    mutate(wap = WAP)
  
}
```

```{r}
# Compute the BidAskSpread for all the snapshots of stock

for (i in 1:length(data_frames)) {
  
  data_frames[[i]] <- data_frames[[i]] %>% mutate(BidAskSpread = ask_price1 / bid_price1 - 1)
  
  data_frames[[i]] <- data_frames[[i]] %>% mutate(time_bucket = ceiling(seconds_in_bucket / 30), num_order = bid_size1 + ask_size1 + bid_size2 + ask_size2)
  
}

```


```{r,message=FALSE}
#log return
set.seed(3888)
Logr_stocks = list()

for (i in 1:length(data_frames)) {


  Log_r <- list() 
  
  timeIDs = unique(data_frames[[i]][, 1])[[1]]
  train_timeIDs = sample(timeIDs, 100)
  # obtain the random 50 time_id for stock, and find log return for each time id.
  
  for (j in 1 : length(train_timeIDs)){
  
    sec <- data_frames[[i]] %>% filter(time_id == train_timeIDs[j]) %>% pull(seconds_in_bucket)
    price <- data_frames[[i]] %>% filter(time_id == train_timeIDs[j]) %>% pull(wap)
    log_r <- log(price[-1] / price[1:(length(price) - 1)])
    Log_r[[j]] <- data.frame(time = sec[-1], log_return = log_r)
    
  }
  
  Logr_stocks[[i]] = Log_r

}

```


```{r}
# 600/30 = 20 data points for each 10-min time bucket
#Length of Volatility should be 25

Volatility = list()

for (j in 1:length(data_frames)) {
  
  Log_r = Logr_stocks[[j]]

  vol <- list()
  
  comp_vol <- function(x) {
    return(sqrt(sum(x ^ 2)))
  }
  
  for (i in 1 : length(Log_r)) {
    Log_r[[i]] <- Log_r[[i]] %>% mutate(time_bucket = ceiling(time / 30))
    vol[[i]] <- aggregate(log_return ~ time_bucket, data = Log_r[[i]], FUN = comp_vol)
    colnames(vol[[i]]) <- c('time_bucket', 'volatility')
  }
  
  Volatility[[j]] = vol

}
```


```{r}
# plot for first time id 
ggplot(data = Volatility[[1]][[1]], aes(x = time_bucket, y = volatility)) + geom_line() + geom_point()
```

```{r}
set.seed(3888)

Logr_stocks_t = list()

for (i in 1:length(data_frames)) {


  Log_r_t <- list() 
  
  timeIDs = unique(data_frames[[i]][, 1])[[1]]
  train_timeIDs = sample(timeIDs, 100)
  
  remaining_timeIDs <- setdiff(timeIDs, train_timeIDs)
  test_timeIDs = sample(remaining_timeIDs, 100)
  # obtain the random 50 time_id for stock, and find log return for each time id.
  
  for (j in 1 : length(test_timeIDs)){
  
    sec <- data_frames[[i]] %>% filter(time_id == test_timeIDs[j]) %>% pull(seconds_in_bucket)
    price <- data_frames[[i]] %>% filter(time_id == test_timeIDs[j]) %>% pull(wap)
    log_r_t <- log(price[-1] / price[1:(length(price) - 1)])
    Log_r_t[[j]] <- data.frame(time = sec[-1], log_return = log_r_t)
    
  }
  
  Logr_stocks_t[[i]] = Log_r_t

}
```



```{r}

Volatility_t = list()

for (j in 1:length(data_frames)) {
  
  Log_r_t = Logr_stocks_t[[j]]

  vol <- list()
  
  comp_vol <- function(x) {
    return(sqrt(sum(x ^ 2)))
  }
  
  for (i in 1 : length(Log_r)) {
    Log_r_t[[i]] <- Log_r_t[[i]] %>% mutate(time_bucket = ceiling(time / 30))
    vol[[i]] <- aggregate(log_return ~ time_bucket, data = Log_r_t[[i]], FUN = comp_vol)
    colnames(vol[[i]]) <- c('time_bucket', 'volatility')
  }
  
  Volatility_t[[j]] = vol

}
```


```{r}
ggplot(data = Volatility_t[[1]][[100]], aes(x = time_bucket, y = volatility)) + geom_line() + geom_point()
```


```{r}
#split the data into training and test sets

set.seed(3888)

Train = list()
Test = list()

for (j in 1:length(data_frames)) {
  
  timeIDs = unique(data_frames[[j]][, 1])[[1]]
  train_timeIDs = sample(timeIDs, 100)
  remaining_timeIDs <- setdiff(timeIDs, train_timeIDs)
  test_timeIDs = sample(remaining_timeIDs, 100)
  
  vol = Volatility[[j]]
  
  train_set <-  data_frames[[j]] %>%
  filter(is.element(time_id, train_timeIDs))
  test_set <-  data_frames[[j]] %>%
  filter(is.element(time_id, test_timeIDs))

  
  Train[[j]] = train_set
  Test[[j]] = test_set
}
```


```{r}
set.seed(3888)
L_reg = list()

for (j in 1:length(data_frames)) {

  list.reg <- list()
  vol = Volatility[[j]]
  
  timeIDs = unique(data_frames[[j]][, 1])[[1]]
  train_timeIDs = sample(timeIDs, 100)
  
  for (i in 1 : length(train_timeIDs)) {
    len.train = length(Volatility[[j]][[i]]$volatility)
    stats.bucket <- data_frames[[j]] %>% 
      filter(time_id == train_timeIDs[i] & time_bucket != 0) %>% 
      dplyr::select(c(BidAskSpread, wap, num_order, time_bucket)) 
    
    # for each 30-sec time bucket, we compute the following statistics
    mean.price <- aggregate(wap ~ time_bucket, data = stats.bucket, FUN = mean)
    mean.order <- aggregate(num_order ~ time_bucket, data = stats.bucket, FUN = mean)
    mean.BAS <- aggregate(BidAskSpread ~ time_bucket, data = stats.bucket, FUN = mean)
    
    list.reg[[i]] <- data.frame(volatility = Volatility[[j]][[i]]$volatility[-1], 
                                price = mean.price$wap[1:(len.train - 1)],
                                order = mean.order$num_order[1:(len.train - 1)],
                                BidAskSpread = mean.BAS$BidAskSpread[1:(len.train - 1)])
  }
  
  L_reg[[j]] = list.reg

}
```



```{r}
set.seed(3888)

Model = list()

for (j in 1:length(data_frames)) {
  
  vol = Volatility[[j]]
  lg = L_reg[[j]]

  # Train the models
  models <- list()
  
  for (i in 1 : length(vol)) {
    models[[i]] <- randomForest(volatility ~ ., data = lg[[i]], ntree = 1000, importance = TRUE)
  }
  
  Model[[j]] = models

}

```

```{r}
print(Model[[1]][[100]])
```



```{r}
set.seed(3888)

L_test = list()

for (j in 1:length(data_frames)) {

    list.reg.test <- list()
    vol = Volatility_t[[j]]
    
  timeIDs = unique(data_frames[[j]][, 1])[[1]]
  train_timeIDs = sample(timeIDs, 100)
    
  remaining_timeIDs <- setdiff(timeIDs, train_timeIDs)
  test_timeIDs = sample(remaining_timeIDs, 100)
  
  for (i in 1 : length(test_timeIDs)) {
    
    len.train = length(Volatility[[j]][[i]]$volatility)
    len.val = length(Volatility_t[[j]][[i]]$volatility)
    
    stats.bucket <- data_frames[[j]] %>% 
      filter(time_id == test_timeIDs[i] & time_bucket != 0) %>% 
      dplyr::select(c(BidAskSpread, wap, num_order, time_bucket))
    mean.price <- aggregate(wap ~ time_bucket, data = stats.bucket, FUN = mean)
    mean.order <- aggregate(num_order ~ time_bucket, data = stats.bucket, FUN = mean)
    mean.BAS <- aggregate(BidAskSpread ~ time_bucket, data = stats.bucket, FUN = mean)
    
    list.reg.test[[i]] <- 
      data.frame(volatility = Volatility_t[[j]][[i]]$volatility, 
                 #price = mean.price$wap[len.train:(len.train + len.val - 1)],
                 price = mean.price$wap[1:(len.val)],
                 #order = mean.order$num_order[len.train:(len.train + len.val - 1)],
                 order = mean.order$num_order[1:(len.val)],
                 #BidAskSpread = mean.BAS$BidAskSpread[len.train:(len.train + len.val - 1)])
                 BidAskSpread = mean.BAS$BidAskSpread[1:(len.val)])
  }
    
  L_test[[j]] = list.reg.test
}
```


```{r}
set.seed(3888)

Prediction = list()

for (j in 1:length(data_frames)) {
  vol = Volatility_t[[j]]
  pred <- list()
  
  for (i in 1 : length(vol)) {
    pred[[i]] <- predict(Model[[j]][[i]], newdata = L_test[[j]][[i]])
  }
  
  Prediction[[j]] = pred
}
```


```{r}
MSE = vector("list", 1)
QLIKE = vector("list", 1)
R_square = vector("list", 1)

for (j in 1:length(data_frames)) {
  
  mse <- vector()
  qlike <- vector()
  rsq <- vector()
  vol = Volatility_t[[j]]

  for (i in 1 : length(vol)) {
    mse <- c(mse, mean((Volatility_t[[j]][[i]]$volatility - Prediction[[j]][[i]]) ^ 2))
    qlike <- c(qlike, mean(Volatility_t[[j]][[i]]$volatility / Prediction[[j]][[i]] - log(Volatility_t[[j]][[i]]$volatility / Prediction[[j]][[i]]) - 1))
    rsq <- c(rsq, cor(Volatility_t[[j]][[i]]$volatility, Prediction[[j]][[i]]) ^ 2)
    
  }
  
  qlike <- qlike[is.finite(qlike)]
  
    
  MSE[[j]] = mse
  QLIKE[[j]] = qlike
  R_square[[j]] = rsq
    
}
```


```{r}
boxplot(MSE[[1]],horizontal = TRUE , main = "Random Forest MSE")
boxplot(QLIKE[[1]], horizontal = TRUE, main = "Random Forest QLIKE")
```


```{r}
plot(MSE[[1]], type = 'l', ylab = "MSE", xlab = "Stocks")
```


```{r,warning=FALSE}
plot(QLIKE[[1]], type = 'l',ylim = c(0,8) ,ylab = "Qlike", xlab = "Stocks")
```

